<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"controllers_basic.js.html":{"id":"controllers_basic.js.html","title":"Source: controllers/basic.js","body":" US Forest Service ePermit Middlelayer API Global buildAutoPopulatedFieldscombinePropArgumentfindFieldgetAllFileNamesgetAllRequiredgetAutoPopulatedFieldsgetBasicFieldsgetBodygetDataToStoreInDBgetFieldsToStoregetValidationSchemahandleAnyOfErrormakeAnyOfMessagemakeErrorObjpostToBasicprepareBasicPostprocessErrorsremoveInstancevalidateBody Source: controllers/basic.js /* ___ ___ ___ _ _ _ ___ ___ | __/ __| ___| _ \\___ _ _ _ __ (_) |_ /_\\ | _ \\_ _| | _|\\__ \\ / -_) _/ -_) '_| ' \\| | _| / _ \\| _/| | |_| |___/ \\___|_| \\___|_| |_|_|_|_|\\__| /_/ \\_\\_| |___| */ //******************************************************************* 'use strict'; //******************************************************************* // required modules const request = require('request-promise'); //******************************************************************* // other files const db = require('./db.js'); const error = require('./error.js'); const basicURL = process.env.BASICURL; //******************************************************************* /** Finds basic API fields are to be auto-populated * @param {Array} basicFields - Fields(Objects) which are stored in SUDS * @return {Array} - Fields(Objects) which are to be auto-populated */ function getAutoPopulatedFields(basicFields){ const autoPop = []; basicFields.forEach((field)=&gt;{ const key = Object.keys(field)[0]; if (!field[key].fromIntake &amp;&amp; field[key].madeOf){ autoPop.push(field); } }); return autoPop; } /** Given list of fields which must be auto-populate, returns values to store * @param {Array} - Array of objects representing Fields which need to be auto-populated * @param {Object} body - user input * @return {Array} - created values */ function buildAutoPopulatedFields(toBuild, body){ const output = {}; toBuild.forEach((field)=&gt;{ const key = Object.keys(field)[0]; let fieldValue = ''; field[key].madeOf.forEach((component)=&gt;{ if (body[component]){ fieldValue = `${fieldValue}${body[component]}`; } else { fieldValue = `${fieldValue}${component}`; } }); output[key] = fieldValue; }); return output; } /** * @param {Array} fields - All fields in object form which will be sent to basicAPI * @param {Object} body - user input * @param {Object} autoPopValues - All values which have been auto-populated * @return {Array} - Array of post objects */ function getBasicFields(fields, body, autoPopValues){ const requests = [], postObjs = []; fields.forEach((field)=&gt;{ const key = Object.keys(field)[0]; const whereToStore = field[key].store; whereToStore.forEach((location)=&gt;{ const requestToUse = location.split(':')[1]; if (location.split(':')[0] === 'basic'){ let postObjExists = false; requests.forEach((request)=&gt;{ const requestKey = Object.keys(request)[0]; if (requestKey === requestToUse){ postObjExists = true; request[requestToUse][key] = field[key]; } }); if (!postObjExists){ const obj = {}; obj[requestToUse] = {}; obj[requestToUse][key] = field[key]; requests.push(obj); } } }); }); requests.forEach((request)=&gt;{ const key = Object.keys(request)[0]; const obj = {}; obj[key] = {}; Object.keys(request[key]).forEach((fieldKey)=&gt;{ const field = request[key][fieldKey]; const fieldPath = fieldKey; const splitPath = fieldPath.split('.'); let bodyField = body; if (field.fromIntake){ splitPath.forEach((sp)=&gt;{ if (bodyField[sp]){ bodyField = bodyField[sp]; } else { bodyField = field.default; } }); obj[key][field.basicField] = bodyField; } else { if (autoPopValues[fieldKey]){ obj[key][field.basicField] = autoPopValues[fieldKey]; } else { obj[key][field.basicField] = field.default; } } }); postObjs.push(obj); }); return postObjs; } /** Takes fields to be stored, creates post objects and populated with user input * @param {Object} sch - validation schema for this request * @param {Object} body - user input * @return {Array} - All post objects */ function prepareBasicPost(sch, body){ const otherFields = []; db.getFieldsToStore(sch, otherFields, '', 'basic'); const toBuild = getAutoPopulatedFields(otherFields); const autoPopulateValues = buildAutoPopulatedFields(toBuild, body); const fieldsToPost = getBasicFields(otherFields, body, autoPopulateValues); return fieldsToPost; } function createContact(fieldsObj, person, postObject){ return new Promise(function(fulfill, reject){ let contactField, createPersonOrOrgURL; if (person){ contactField = fieldsObj['/contact/person']; createPersonOrOrgURL = `${basicURL}/contact/person/`; } else { contactField = fieldsObj['/contact/organization']; createPersonOrOrgURL = `${basicURL}/contact/orgcode/`; } postObject['/contact/personOrOrgcode'].request = contactField; const createContactOptions = { method: 'POST', uri: createPersonOrOrgURL, body: contactField, json: true }; request(createContactOptions) .then(function(res){ postObject['/contact/personOrOrgcode'].response = res; const cn = res.contCn; const addressField = fieldsObj['/contact/address']; addressField.contact = cn; const addressURL = `${basicURL}/contact-address/`; postObject['/contact-address'].request = addressField; const createAddressOptions = { method: 'POST', uri: addressURL, body: addressField, json: true }; return request(createAddressOptions); }) .then(function(res){ postObject['/contact-address'].response = res; const cn = res.contact; const phoneField = fieldsObj['/contact/phone']; phoneField.contact = cn; const phoneURL = `${basicURL}/contact-phone/`; postObject['/contact-phone'].request = phoneField; const createPhoneOptions = { method: 'POST', uri: phoneURL, body: phoneField, json: true }; return request(createPhoneOptions); }) .then(function(res){ postObject['/contact-phone'].response = res; fulfill(res.contact); }) .catch(function(err){ reject(err); }); }); } /** Sends requests needed to create an application via the Basic API * @param {Object} req - Request Object * @param {Object} res - Response Object * @param {Object} sch - Schema object * @param {Object} body - User input */ function postToBasic(req, res, sch, body, controlNumber){ //Should remove control number once we get from BASIC api const postObject = { '/contact/personOrOrgcode':{}, '/contact-address':{}, '/contact-phone':{}, '/application':{} }; const fieldsToPost = prepareBasicPost(sch, body); const fieldsObj = {}; fieldsToPost.forEach((post)=&gt;{ const key = Object.keys(post)[0]; fieldsObj[key] = post[key]; }); const org = (body.applicantInfo.orgType &amp;&amp; body.applicantInfo.orgType !== 'Individual'); let existingContactCheck; if (org){ let orgName = body.applicantInfo.organizationName; if (!orgName){ orgName = 'abc'; } existingContactCheck = `${basicURL}/contact/orgcode/${orgName}/`; } else { const lastName = body.applicantInfo.lastName; existingContactCheck = `${basicURL}/contact/person/${lastName}/`; } const getContactOptions = { method: 'GET', uri: existingContactCheck, qs:{}, json: true }; request(getContactOptions) .then(function(res){ if (res.contCN){ Promise.resolve(res.contCN); } else { return createContact(fieldsObj, true, postObject); } }) .then(function(contCN){ const createApplicationURL = `${basicURL}/application/`; fieldsObj['/application'].contCn = contCN; const applicationPost = fieldsObj['/application']; postObject['/application'].request = applicationPost; const createApplicationOptions = { method: 'POST', uri: createApplicationURL, body: applicationPost, json: true }; return request(createApplicationOptions); }) .then(function(response){ postObject['/application'].response = response; const jsonResponse = {}; jsonResponse.success = true; jsonResponse.api = 'FS ePermit API'; jsonResponse.type = 'controller'; jsonResponse.verb = req.method; jsonResponse.src = 'json'; jsonResponse.route = req.originalUrl; jsonResponse.controlNumber = controlNumber; jsonResponse.apiRequest = body; jsonResponse.basicPosts = postObject; return res.json(jsonResponse); }) .catch(function(err){ return error.sendError(req, res, 500, err); }); } module.exports.postToBasic = postToBasic; Ã— Search results Close Documentation generated by JSDoc 3.4.3 on April 11, 2017 using the DocStrap template. "},"controllers_validation.js.html":{"id":"controllers_validation.js.html","title":"Source: controllers/validation.js","body":" US Forest Service ePermit Middlelayer API Global buildAutoPopulatedFieldscombinePropArgumentfindFieldgetAllFileNamesgetAllRequiredgetAutoPopulatedFieldsgetBasicFieldsgetBodygetDataToStoreInDBgetFieldsToStoregetValidationSchemahandleAnyOfErrormakeAnyOfMessagemakeErrorObjpostToBasicprepareBasicPostprocessErrorsremoveInstancevalidateBody Source: controllers/validation.js /* ___ ___ ___ _ _ _ ___ ___ | __/ __| ___| _ \\___ _ _ _ __ (_) |_ /_\\ | _ \\_ _| | _|\\__ \\ / -_) _/ -_) '_| ' \\| | _| / _ \\| _/| | |_| |___/ \\___|_| \\___|_| |_|_|_|_|\\__| /_/ \\_\\_| |___| */ //******************************************************************* 'use strict'; //******************************************************************* // required modules const path = require('path'); const Validator = require('jsonschema').Validator; const include = require('include')(__dirname); //******************************************************************* // other files const errors = require('./patternErrorMessages.json'); const v = new Validator(); const fileMimes = [ 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'application/msword', 'text/rtf', 'application/pdf' ]; function digitCheck(input, num){ let valid = true; if (typeof input === 'number'){ const inputStr = input + ''; if (!inputStr.match(new RegExp(`^[0-9]{${num}}$`))){ valid = false; } } return valid; } function areaCodeFormat(input){ return digitCheck(input, 3); } function phoneNumberFormat(input){ return digitCheck(input, 7); } /** * Removes 'instance' from prop field of validation errors. Used to make fields human readable * * @param {string} prop - Prop field from validation error * @return {string} */ function removeInstance(prop){ let fixedProp = ''; if (prop.indexOf('.') !== -1){ fixedProp = prop.substring((prop.indexOf('.') + 1), (prop.length)); } return fixedProp; } /** * Combines property and argument fields, if property exists, for missing field errors * * @param {string} property - Upper field to combine * @param {string} argument - Field where error is. * @return {string} - Concatination of property, '.', and argument */ function combinePropArgument(property, argument){ let field; if (property.length &gt; 0){ field = `${property}.${argument}`; } else { field = argument; } return field; } /** * Creates error object which can be read by error message building function * * @param {string} field - Field where error occured at * @param {string} errorType - Type of error returned * @param {string} expectedFieldType - Type that the field is expected to be * @param {string} enumMessage - Enum message returned by validation * @param {string} dependency - Fields that are a dependeny of field * @param {array} anyOfFields - Array of strings of all field included in anyOf * * @return Error object */ function makeErrorObj(field, errorType, expectedFieldType, enumMessage, dependency, anyOfFields){ const output = { field, errorType, expectedFieldType, enumMessage, dependency, anyOfFields }; let key; for (key in output){ if (output[key] === null){ delete output[key]; } } return output; } let requiredFields = []; function checkForExtraRequired(schema){ const keys = schema.properties; for (const key in keys){ if (schema.properties[key].type === 'object' &amp;&amp; schema.required.includes(key)){ const indexOfSuper = requiredFields.indexOf(key) + 1; requiredFields.splice(indexOfSuper, 0, ...schema.properties[key].required.map(function(s){ return `${key}.${s}`; })); checkForExtraRequired(schema.properties[key]); } } } /** Traverses schema object in search of all fields listed as required. Stores all fields in requiredFiles array. * @param {Object} schema - schema to traverse in search for all required fields */ function getAllRequired(schema){ const keys = Object.keys(schema); keys.forEach((key)=&gt;{ switch (key){ case 'allOf': schema.allOf.forEach((sch)=&gt;{ getAllRequired(sch); }); break; case 'properties': getAllRequired(schema.properties); break; case 'required': requiredFields = requiredFields.concat(schema.required); checkForExtraRequired(schema); } }); } /** Traverses through schema to find field specified. Once found it executes a function on that field in the schema. * @param {Object} schema - schema to look for field in * @param {Array} field - Array(String) containing the path to the field to find * @param {Function} func - Function to be run on the schema of field */ function findField(schema, field, func){ const fieldCopy = JSON.parse(JSON.stringify(field)); const schemaKeys = Object.keys(schema); schemaKeys.forEach((key)=&gt;{ if (key === fieldCopy[0]){ if (fieldCopy.length === 1){ func(schema[key]); } else { fieldCopy.shift(); findField(schema[key], fieldCopy, func); } } else { switch (key){ case 'allOf': case 'oneOf': schema[key].forEach((sch)=&gt;{ findField(sch, fieldCopy, func); }); break; case 'properties': findField(schema.properties, fieldCopy, func); break; } } }); } function handleMissingError(output, result, counter, schema){ requiredFields = []; const property = removeInstance(result[counter].property); const field = combinePropArgument(property, result[counter].argument); output.errorArray.push(makeErrorObj(field, 'missing')); findField(schema, field.split('.'), getAllRequired); for (const i in requiredFields){ requiredFields[i] = `${field}.${requiredFields[i]}`; } requiredFields.forEach((requiredField)=&gt;{ output.errorArray.push(makeErrorObj(requiredField, 'missing')); }); } function handleTypeError(output, result, counter){ const expectedType = result[counter].argument[0]; const property = removeInstance(result[counter].property); output.errorArray.push(makeErrorObj(property, 'type', expectedType)); } function handleFormatError(output, result, counter){ const field = `${removeInstance(result[counter].property)}`; output.errorArray.push(makeErrorObj(field, 'format')); } function handleEnumError(output, result, counter){ const property = removeInstance(result[counter].property); output.errorArray.push(makeErrorObj(property, 'enum', null, result[counter].message)); } function getDependency(result, counter){ const stackMessage = result[counter].stack; const dependency = stackMessage.split(' property ')[1].split(' not ')[0]; return dependency; } function handleDependencyError(output, result, counter){ const error = result[counter]; const dependentField = removeInstance(error.argument); const schemaPath = removeInstance(error.property); const dependency = `${schemaPath}.${getDependency(result, counter)}`; output.errorArray.push(makeErrorObj(dependentField, 'dependencies', null, null, dependency)); } /** * Creates error object for errors resulting from an anyOf section of the validation schema * * @param {object} errorTracking - Error object containing all error to report and the error message to deliver. * @param {array} errorTracking.errorArray - Array contain all errors to report to user. * @param {array} result - Array of errors found during validation. * @param {integer} counter - Position in result that the current error being handled is. * * @affects errorTracking.errorArray */ function handleAnyOfError(errorTracking, result, counter){ const error = result[counter]; const property = removeInstance(error.property); const requiredOptions = []; error.schema.anyOf.forEach((fieldObj)=&gt;{ requiredOptions.push(combinePropArgument(property, fieldObj.required[0])); }); errorTracking.errorArray.push(makeErrorObj(null, 'anyOf', null, null, null, requiredOptions)); } /** Get the schema to be used for validating user input * @param {Object} pathData - All data from swagger for the path that has been run * @return {Object} schemas - fullSchema is the full validation schemas for all permit types. schemaToUse is the validation schema for this route */ function getValidationSchema(pathData){ const fileToGet = `controllers/${pathData.validation.$ref.split('#')[0]}`; const schemaToGet = pathData.validation.$ref.split('#')[1]; const applicationSchema = include(fileToGet); return { 'fullSchema':applicationSchema, 'schemaToUse':applicationSchema[schemaToGet] }; } /** Validates the fields in user input * @param {Object} body - Input from user to be validated * @param {Object} pathData - All data from swagger for the path that has been run * @return {Array} - Array of ValidationErrors from validation */ function validateBody(body, pathData){ const schema = getValidationSchema(pathData); const applicationSchema = schema.fullSchema; const schemaToUse = schema.schemaToUse; let key; for (key in applicationSchema){ v.addSchema(applicationSchema[key], key); } v.customFormats.areaCodeFormat = areaCodeFormat; v.customFormats.phoneNumberFormat = phoneNumberFormat; const val = v.validate(body, schemaToUse); const error = val.errors; return error; } /** Processes ValidationError into ErrorObj, extracting the info needed to create an error message * @param {Array} - Array of ValidationErrors from validation * @param {Array} - Array to store processed ErrorObjs in */ function processErrors(errors, processedErrors, schema){ const length = errors.length; let counter; for (counter = 0; counter &lt; length; counter++){ switch (errors[counter].name){ case 'required': handleMissingError(processedErrors, errors, counter, schema); break; case 'type': handleTypeError(processedErrors, errors, counter); break; case 'format': case 'pattern': handleFormatError(processedErrors, errors, counter); break; case 'enum': handleEnumError(processedErrors, errors, counter); break; case 'dependencies': handleDependencyError(processedErrors, errors, counter); break; case 'anyOf': handleAnyOfError(processedErrors, errors, counter); break; } } } function makeFieldReadable(input){ return input .replace(/([A-Z])/g, ' $1') .replace(/^./, function(str){ return str.toUpperCase(); }) .replace('Z I P', 'Zip') .replace('U R L', 'URL'); } function makePathReadable(input){ if (typeof input === 'string'){ const parts = input.split('.'); const readableParts = []; let readablePath = ''; parts.forEach((field)=&gt;{ readableParts.push(makeFieldReadable(field)); }); readablePath = readableParts.shift(); readableParts.forEach((part)=&gt;{ readablePath = `${readablePath}/${part}`; }); return readablePath; } else { return false; } } function buildFormatErrorMessage(fullPath){ const field = fullPath.substring(fullPath.lastIndexOf('.') + 1); const readablePath = makePathReadable(fullPath); const errorMessage = `${readablePath}${errors[field]}`; return errorMessage; } /** * Creates error message for anyOf errors * * @param {array} anyOfFields - list of fields, at least one being required. * @return {string} */ function makeAnyOfMessage(anyOfFields){ if (anyOfFields){ let output, count = 1; const length = anyOfFields.length; output = `${makePathReadable(anyOfFields[0])}`; while (count &lt; length) { const field = anyOfFields[count]; output = `${output} or ${makePathReadable(field)}`; count ++; } return output; } else { return false; } } function concatErrors(errorMessages){ let output = ''; errorMessages.forEach((message)=&gt;{ output = `${output}${message} `; }); output = output.trim(); return output; } function generateFileErrors(output, error, messages){ const reqFile = `${makePathReadable(error.field)} is a required file.`; const small = `${makePathReadable(error.field)} cannot be an empty file.`; const large = `${makePathReadable(error.field)} cannot be larger than ${error.expectedFieldType} MB.`; let invExt, invMime; if (typeof(error.expectedFieldType) !== 'undefined' &amp;&amp; error.expectedFieldType.constructor === Array){ invExt = `${makePathReadable(error.field)} must be one of the following extensions: ${error.expectedFieldType.join(', ')}.`; invMime = `${makePathReadable(error.field)} must be one of the following mime types: ${error.expectedFieldType.join(', ')}.`; } switch (error.errorType){ case 'requiredFileMissing': messages.push(reqFile); error.message = reqFile; break; case 'invalidExtension': messages.push(invExt); error.message = invExt; break; case 'invalidMime': messages.push(invMime); error.message = invMime; break; case 'invalidSizeSmall': messages.push(small); error.message = small; break; case 'invalidSizeLarge': messages.push(large); error.message = large; break; } } function generateErrorMesage(output){ let errorMessage = ''; const messages = []; output.errorArray.forEach((error)=&gt;{ const missing = `${makePathReadable(error.field)} is a required field.`; const type = `${makePathReadable(error.field)} is expected to be type '${error.expectedFieldType}'.`; const enumMessage = `${makePathReadable(error.field)} ${error.enumMessage}.`; const dependencies = `Having ${makePathReadable(error.field)} requires that ${makePathReadable(error.dependency)} be provided.`; const anyOf = `Either ${makeAnyOfMessage(error.anyOfFields)} is a required field.`; switch (error.errorType){ case 'missing': messages.push(missing); error.message = missing; break; case 'type': messages.push(type); error.message = type; break; case 'format': case 'pattern': messages.push(buildFormatErrorMessage(error.field)); error.message = buildFormatErrorMessage(error.field); break; case 'enum': messages.push(enumMessage); error.message = enumMessage; break; case 'dependencies': messages.push(dependencies); error.message = dependencies; break; case 'anyOf': messages.push(anyOf); error.message = anyOf; break; default: generateFileErrors(output, error, messages); break; } }); errorMessage = concatErrors(messages); return errorMessage; } function checkForFilesInSchema(schema, toCheck){ const keys = Object.keys(schema); keys.forEach((key)=&gt;{ switch (key){ case 'allOf': schema.allOf.forEach((sch)=&gt;{ checkForFilesInSchema(sch, toCheck); }); break; case 'properties': checkForFilesInSchema(schema.properties, toCheck); break; default: if (schema[key].type === 'file'){ const obj = {}; obj[key] = schema[key]; toCheck.push(obj); } else if (schema[key].type === 'object'){ checkForFilesInSchema(schema[key], toCheck); } break; } }); } function getFileInfo(file, constraints){ const uploadFile = {}; const uploadField = Object.keys(constraints)[0]; if (file){ const filename = path.parse(file[0].originalname).name; uploadFile.file = file[0]; uploadFile.originalname = uploadFile.file.originalname; uploadFile.filetype = Object.keys(constraints)[0]; uploadFile.filetypecode = constraints[uploadFile.filetype].filetypecode; uploadFile.ext = path.parse(uploadFile.file.originalname).ext.split('.')[1]; uploadFile.size = uploadFile.file.size; uploadFile.mimetype = uploadFile.file.mimetype; uploadFile.encoding = uploadFile.file.encoding; uploadFile.buffer = uploadFile.file.buffer; uploadFile.filename = uploadField + '-' + filename + '-' + Date.now() + '.' + uploadFile.ext; } return uploadFile; } function validateFile(uploadFile, validationConstraints, fileName){ const fileInfo = getFileInfo(uploadFile, validationConstraints); const constraints = validationConstraints[fileName]; const regex = `(^${constraints.validExtensions.join('$|^')}$)`; const errObjs = []; if (uploadFile){ if (fileInfo.ext &amp;&amp; !fileInfo.ext.toLowerCase().match(regex)){ errObjs.push(makeErrorObj(fileInfo.filetype, 'invalidExtension', constraints.validExtensions)); } else if (fileMimes.indexOf(fileInfo.mimetype) &lt; 0){ errObjs.push(makeErrorObj(fileInfo.filetype, 'invalidMime', fileMimes)); } if (fileInfo.size === 0){ errObjs.push(makeErrorObj(fileInfo.filetype, 'invalidSizeSmall', 0)); } else { const fileSizeInMegabytes = fileInfo.size / 1000000.0; if (fileSizeInMegabytes &gt; constraints.maxSize){ errObjs.push(makeErrorObj(fileInfo.filetype, 'invalidSizeLarge', constraints.maxSize)); } } } else if (constraints.requiredFile){ errObjs.push(makeErrorObj(fileName, 'requiredFileMissing')); } return errObjs; } function getFieldValidationErrors(body, pathData, derefSchema){ const processedFieldErrors = { errorArray:[] }; const fieldErrors = validateBody(body, pathData); if (fieldErrors.length &gt; 0){ processErrors(fieldErrors, processedFieldErrors, derefSchema); } return processedFieldErrors; } module.exports.removeInstance = removeInstance; module.exports.combinePropArgument = combinePropArgument; module.exports.makeErrorObj = makeErrorObj; module.exports.getAllRequired = getAllRequired; module.exports.findField = findField; module.exports.handleMissingError = handleMissingError; module.exports.handleTypeError = handleTypeError; module.exports.handleFormatError = handleFormatError; module.exports.handleEnumError = handleEnumError; module.exports.getDependency = getDependency; module.exports.handleDependencyError = handleDependencyError; module.exports.handleAnyOfError = handleAnyOfError; module.exports.getValidationSchema = getValidationSchema; module.exports.validateBody = validateBody; module.exports.processErrors = processErrors; module.exports.makeFieldReadable = makeFieldReadable; module.exports.makePathReadable = makePathReadable; module.exports.buildFormatErrorMessage = buildFormatErrorMessage; module.exports.makeAnyOfMessage = makeAnyOfMessage; module.exports.concatErrors = concatErrors; module.exports.generateFileErrors = generateFileErrors; module.exports.generateErrorMesage = generateErrorMesage; module.exports.checkForFilesInSchema = checkForFilesInSchema; module.exports.getFileInfo = getFileInfo; module.exports.validateFile = validateFile; module.exports.getFieldValidationErrors = getFieldValidationErrors; Ã— Search results Close Documentation generated by JSDoc 3.4.3 on April 11, 2017 using the DocStrap template. "},"routes_controllers_index.js.html":{"id":"routes_controllers_index.js.html","title":"Source: routes/controllers/index.js","body":" US Forest Service ePermit Middlelayer API Global buildAutoPopulatedFieldscombinePropArgumentfindFieldgetAllFileNamesgetAllRequiredgetAutoPopulatedFieldsgetBasicFieldsgetBodygetDataToStoreInDBgetFieldsToStoregetValidationSchemahandleAnyOfErrormakeAnyOfMessagemakeErrorObjpostToBasicprepareBasicPostprocessErrorsremoveInstancevalidateBody Source: routes/controllers/index.js /* ___ ___ ___ _ _ _ ___ ___ | __/ __| ___| _ \\___ _ _ _ __ (_) |_ /_\\ | _ \\_ _| | _|\\__ \\ / -_) _/ -_) '_| ' \\| | _| / _ \\| _/| | |_| |___/ \\___|_| \\___|_| |_|_|_|_|\\__| /_/ \\_\\_| |___| */ //******************************************************************* 'use strict'; //******************************************************************* // required modules const express = require('express'); const router = express.Router(); const include = require('include')(__dirname); const multer = require('multer'); const controller = include('controllers'); const apiSchema = include('docs/swagger.json'); //******************************************************************* // storage const storage = multer.memoryStorage(); const upload = multer({ storage: storage }); //******************************************************************* /** Function to retrieve all of the files that might be expected by any route. * @return {Array} - Array of objects used by multer to describe the files that can be expected. */ function getAllFileNames() { const allFilesNames = []; if (apiSchema) { for (const k in apiSchema.paths) { for (const l in apiSchema.paths[k]) { if (apiSchema.paths[k][l].parameters) { for (let i = 0; i &lt; apiSchema.paths[k][l].parameters.length; i++) { if (apiSchema.paths[k][l].parameters[i].type === 'file') { allFilesNames.push({ name: apiSchema.paths[k][l].parameters[i].name, maxCount: 1 }); } } } } } } return allFilesNames; } const postUploadFields = upload.fields(getAllFileNames()); //******************************************************************* // router // trailing slash middleware router.use('/*', function(req, res, next){ const reqPath = `/${req.params[0]}`; if (reqPath.slice(-1) !== '/') { res.redirect(301, reqPath + '/'); } next(); }); // api router to controller router.use('/*', postUploadFields, function(req, res, next){ controller.use(req, res); }); //******************************************************************* //exports module.exports = router; Ã— Search results Close Documentation generated by JSDoc 3.4.3 on April 11, 2017 using the DocStrap template. "},"controllers_index.js.html":{"id":"controllers_index.js.html","title":"Source: controllers/index.js","body":" US Forest Service ePermit Middlelayer API Global buildAutoPopulatedFieldscombinePropArgumentfindFieldgetAllFileNamesgetAllRequiredgetAutoPopulatedFieldsgetBasicFieldsgetBodygetDataToStoreInDBgetFieldsToStoregetValidationSchemahandleAnyOfErrormakeAnyOfMessagemakeErrorObjpostToBasicprepareBasicPostprocessErrorsremoveInstancevalidateBody Source: controllers/index.js /* ___ ___ ___ _ _ _ ___ ___ | __/ __| ___| _ \\___ _ _ _ __ (_) |_ /_\\ | _ \\_ _| | _|\\__ \\ / -_) _/ -_) '_| ' \\| | _| / _ \\| _/| | |_| |___/ \\___|_| \\___|_| |_|_|_|_|\\__| /_/ \\_\\_| |___| */ //******************************************************************* 'use strict'; //******************************************************************* // required modules const include = require('include')(__dirname); const async = require('async'); const deref = require('deref'); const matchstick = require('matchstick'); const apiSchema = include('docs/swagger.json'); //******************************************************************* // other files const error = require('./error.js'); const get = require('./get.js'); const aws = require('./aws.js'); const db = require('./db.js'); const basic = require('./basic.js'); const validation = require('./validation.js'); //************************************************************* // Helper Functions function getBasicRes(pathData){ return include(pathData.mockOutput); } function apiSchemaData(apiSchema, reqPath){ if (apiSchema) { for (const k in apiSchema.paths) { const ms = matchstick(k, 'template'); ms.match(reqPath); if ( ms.match(reqPath) ) { return { path: k, tokens: ms.tokens, matches: ms.matches }; } } } } /** If body passed in as string, converts it to a JSON object * @param {Object} req - request object * @return {Object} - request body as a JSON Object */ function getBody(req){ let inputPost = req.body; if (inputPost.body) { inputPost = JSON.parse(inputPost.body); } return inputPost; } function saveAndUploadFiles(req, res, possbileFiles, files, controlNumber, application, callback){ const asyncTasks = []; possbileFiles.forEach((fileConstraints)=&gt;{ asyncTasks.push(function(callback){ const key = Object.keys(fileConstraints)[0]; if (files[key]){ const fileInfo = validation.getFileInfo(files[key], fileConstraints); fileInfo.keyname = `${controlNumber}/${fileInfo.filename}`; db.saveFile(application.id, fileInfo, function(err){ if (err){ return error.sendError(req, res, 500, `${fileInfo.filetype} failed to save`); } else { aws.uploadFile(fileInfo, callback); } }); } else { return callback (null, null); } }); }); async.parallel(asyncTasks, function(err, data){ if (err){ return callback(err, null); } else { return callback(null, data); } }); } //******************************************************************* // controller functions const getControlNumberFileName = function(req, res, reqData) { const controlNumber = reqData.matches.controlNumber; const fileName = reqData.matches.fileName; const filePath = controlNumber + '/' + fileName; db.getFile(filePath, function (err, file){ if (err){ error.sendError(req, res, 400, 'error getting file'); } else { if (file){ aws.getFile(controlNumber, fileName, function(err, data){ if (err){ error.sendError(req, res, 404, 'file not found'); } else { res.attachment(file.file_name); res.send(data.Body); } }); } else { error.sendError(req, res, 400, 'Invalid controlNumber or fileName provided'); } } }); }; const getControlNumber = function(req, res, reqData){ const pathData = reqData.schema; const fileTypes = { 'gud': 'guideDocumentation', 'arf': 'acknowledgementOfRiskForm', 'inc': 'insuranceCertificate', 'gse': 'goodStandingEvidence', 'opp': 'operatingPlan' }; const basicData = getBasicRes(pathData); let jsonData = {}; const controlNumber = reqData.matches.controlNumber; const jsonResponse = {}; jsonResponse.success = true; jsonResponse.api = 'FS ePermit API'; jsonResponse.type = 'controller'; jsonResponse.verb = req.method; jsonResponse.src = 'json'; jsonResponse.route = req.originalUrl; const cnData = basicData[1095010356]; // TODO: remove - used for mocks if (basicData){ db.getApplication(controlNumber, function(err, appl, fileData){ if (err){ return error.sendError(req, res, 400, 'error getting application from database'); } else { if (fileData){ fileData.forEach(function(file){ const fileType = fileTypes[file.file_type]; appl[fileType] = file.file_name; }); } jsonData = get.copyGenericInfo(cnData, appl, jsonData, pathData.getTemplate); jsonData.controlNumber = controlNumber;// TODO: remove - used for mocks const toReturn = Object.assign({}, {response:jsonResponse}, jsonData); res.json(toReturn); } }); } }; //************************************************************* const postApplication = function(req, res, reqData){ const pathData = reqData.schema; const body = getBody(req); const derefFunc = deref(); const possbileFiles = []; const schema = validation.getValidationSchema(pathData); const sch = derefFunc(schema.schemaToUse, [schema.fullSchema]); const allErrors = validation.getFieldValidationErrors(body, pathData, sch); //Files to validate are in possbileFiles validation.checkForFilesInSchema(sch, possbileFiles); if (possbileFiles.length !== 0){ possbileFiles.forEach((fileConstraints)=&gt;{ const key = Object.keys(fileConstraints)[0]; const fileValidationErrors = validation.validateFile(req.files[key], fileConstraints, key); allErrors.errorArray = allErrors.errorArray.concat(fileValidationErrors); }); } const errorMessage = validation.generateErrorMesage(allErrors); if (allErrors.errorArray.length !== 0){ return error.sendError(req, res, 400, errorMessage, allErrors.errorArray); } else { const toStoreInDB = db.getDataToStoreInDB(sch, body); const controlNumber = (Math.floor((Math.random() * 10000000000) + 1)).toString(); //TODO: remove - used for mocks toStoreInDB.control_number = controlNumber; db.saveApplication(controlNumber, toStoreInDB, function(err, appl){ if (err){ return error.sendError(req, res, 500, err); } else { saveAndUploadFiles(req, res, possbileFiles, req.files, controlNumber, appl, function(err, data){ if (err) { return error.sendError(req, res, 500, err); } else { basic.postToBasic(req, res, sch, body, controlNumber); } }); } }); } }; const use = function(req, res){ const reqPath = `/${req.params[0]}`; const reqMethod = req.method.toLowerCase(); const apiReqData = apiSchemaData(apiSchema, reqPath); if (apiReqData){ const apiPath = apiReqData.path; const apiTokens = apiReqData.tokens; const apiMatches = apiReqData.matches; if (!apiPath) { return error.sendError(req, res, 404, 'Invalid endpoint.'); } else { if (!apiSchema.paths[apiPath][reqMethod]) { return error.sendError(req, res, 405, 'No endpoint method found.'); } else { if (!apiSchema.paths[apiPath][reqMethod].responses) { return error.sendError(req, res, 500, 'No endpoint responses found.'); } else { if (!apiSchema.paths[apiPath][reqMethod].responses['200']) { return error.sendError(req, res, 500, 'No endpoint success found.'); } else { const schemaData = apiSchema.paths[apiPath][reqMethod]; const reqData = { path: apiPath, tokens: apiTokens, matches: apiMatches, schema: schemaData }; if (reqMethod === 'get') { if (apiTokens.includes('fileName')) { getControlNumberFileName(req, res, reqData); } else { getControlNumber(req, res, reqData); } } else if (reqMethod === 'post') { postApplication(req, res, reqData); } } } } } } else { return error.sendError(req, res, 404, 'Invalid endpoint.'); } }; //******************************************************************* // exports module.exports.use = use; Ã— Search results Close Documentation generated by JSDoc 3.4.3 on April 11, 2017 using the DocStrap template. "},"controllers_db.js.html":{"id":"controllers_db.js.html","title":"Source: controllers/db.js","body":" US Forest Service ePermit Middlelayer API Global buildAutoPopulatedFieldscombinePropArgumentfindFieldgetAllFileNamesgetAllRequiredgetAutoPopulatedFieldsgetBasicFieldsgetBodygetDataToStoreInDBgetFieldsToStoregetValidationSchemahandleAnyOfErrormakeAnyOfMessagemakeErrorObjpostToBasicprepareBasicPostprocessErrorsremoveInstancevalidateBody Source: controllers/db.js /* ___ ___ ___ _ _ _ ___ ___ | __/ __| ___| _ \\___ _ _ _ __ (_) |_ /_\\ | _ \\_ _| | _|\\__ \\ / -_) _/ -_) '_| ' \\| | _| / _ \\| _/| | |_| |___/ \\___|_| \\___|_| |_|_|_|_|\\__| /_/ \\_\\_| |___| */ //******************************************************************* 'use strict'; //******************************************************************* // required modules //******************************************************************* // other files const include = require('include')(__dirname); const models = include('models'); //******************************************************************* function saveFile(applicationId, uploadFile, callback){ models.files.create({ application_id: applicationId, file_type: uploadFile.filetypecode, file_path: uploadFile.keyname, file_name: uploadFile.filename, file_originalname: uploadFile.originalname, file_ext: uploadFile.ext, file_size: uploadFile.size, file_mimetype: uploadFile.mimetype, file_encoding: uploadFile.encoding }) .then(function(file) { return callback(null, file); }) .catch(function(err) { return callback(err, null); }); } const getFile = function(filePath, callback){ models.files.findOne({ where: {file_path: filePath} }) .then(function(file) { return callback(null, file); }) .catch(function(err) { console.error(err); return callback(err, null); }); }; const getFiles = function(applicationId, callback){ models.files.findAll({ where: {application_id: applicationId} }) .then(function(files) { return callback(null, files); }) .catch(function(err) { return callback(err, null); }); }; const getApplication = function(controlNumber, callback){ models.applications.findOne({ where: { control_number: controlNumber } }).then(function(appl) { if (appl){ if (appl.form_name === 'FS-2700-3f') { getFiles(appl.id, function(fileErr, files) { if (fileErr){ console.error(fileErr); return callback(fileErr, null, null); } else { if (files) { return callback(null, appl, files); } else { return callback(null, appl, null); } } }); } else { return callback(null, appl, null); } } else { return callback('no record found', null); } }).catch(function (err) { console.error(err); return callback(err, null, null); }); }; const saveApplication = function(controlNumber, toStore, callback) { models.applications.create(toStore) .then(function(appl) { return callback(null, appl); }) .catch(function(err) { console.error(err); return callback(err, null); }); }; /** Gets list of fields that are to be stored in DB * @param {Object} schema - Schema to look through to find any fields to store in DB * @param {Array} fieldsToStore - Array(String) containing names of field to store in DB * @param {String} path - path to each field from root of schema * @param {String} saveLocation - location which field should be saved. Valid options are middleLayer or basic. */ function getFieldsToStore(schema, fieldsToStore, path, saveLocation){ const keys = Object.keys(schema); keys.forEach((key)=&gt;{ switch (key){ case 'allOf': case 'oneOf': for (let i = 0; i &lt; schema[key].length; i++){ getFieldsToStore(schema[key][i], fieldsToStore, `${path}`, saveLocation); } break; case 'properties': getFieldsToStore(schema.properties, fieldsToStore, `${path}`, saveLocation); break; default: const store = schema[key].store; let storeInMiddle = false; if (store &amp;&amp; schema[key].type !== 'file'){ store.forEach((place)=&gt;{ const location = place.split(':')[0]; storeInMiddle = storeInMiddle || (location === saveLocation); }); } if (storeInMiddle){ const obj = {}; if (path !== ''){ obj[`${path.slice(path.indexOf('.') + 1)}.${key}`] = schema[key]; } else { obj[`${key}`] = schema[key]; } fieldsToStore.push(obj); } else if (schema[key].type === 'object'){ getFieldsToStore(schema[key], fieldsToStore, `${path}.${key}`, saveLocation); } break; } }); } /** Formats data from user input, that needs to be submitted to DB, so that DB can receive it. * @param {Object} schema - Schema of application being submitted * @param {Object} body - User input * @return {Object} - Containing key:value pairs for all fields expected to be stored in DB */ function getDataToStoreInDB(schema, body){ const fieldsToStoreInDB = []; const output = {}; getFieldsToStore(schema, fieldsToStoreInDB, '', 'middleLayer'); fieldsToStoreInDB.forEach((field)=&gt;{ const path = Object.keys(field)[0]; const splitPath = path.split('.'); let bodyField = body; splitPath.forEach((sp)=&gt;{ bodyField = bodyField[sp]; }); if ((typeof bodyField) === 'undefined'){ bodyField = field[path].default; } const dbField = field[path].store[0].split(':')[1]; output[dbField] = bodyField; }); return output; } module.exports.getDataToStoreInDB = getDataToStoreInDB; module.exports.getFieldsToStore = getFieldsToStore; module.exports.saveFile = saveFile; module.exports.getFile = getFile; module.exports.getFiles = getFiles; module.exports.getApplication = getApplication; module.exports.saveApplication = saveApplication; Ã— Search results Close Documentation generated by JSDoc 3.4.3 on April 11, 2017 using the DocStrap template. "},"global.html":{"id":"global.html","title":"Global","body":" US Forest Service ePermit Middlelayer API Global buildAutoPopulatedFieldscombinePropArgumentfindFieldgetAllFileNamesgetAllRequiredgetAutoPopulatedFieldsgetBasicFieldsgetBodygetDataToStoreInDBgetFieldsToStoregetValidationSchemahandleAnyOfErrormakeAnyOfMessagemakeErrorObjpostToBasicprepareBasicPostprocessErrorsremoveInstancevalidateBody Global Methods buildAutoPopulatedFields(toBuild, body) Given list of fields which must be auto-populate, returns values to store Parameters: Name Type Description toBuild Array Array of objects representing Fields which need to be auto-populated body Object user input Source: controllers/basic.js, line 46 Returns: created values Type Array combinePropArgument(property, argument) Combines property and argument fields, if property exists, for missing field errors Parameters: Name Type Description property string Upper field to combine argument string Field where error is. Source: controllers/validation.js, line 92 Returns: Concatination of property, '.', and argument Type string findField(schema, field, func) Traverses through schema to find field specified. Once found it executes a function on that field in the schema. Parameters: Name Type Description schema Object schema to look for field in field Array Array(String) containing the path to the field to find func function Function to be run on the schema of field Source: controllers/validation.js, line 179 getAllFileNames() Function to retrieve all of the files that might be expected by any route. Source: routes/controllers/index.js, line 38 Returns: Array of objects used by multer to describe the files that can be expected. Type Array getAllRequired(schema) Traverses schema object in search of all fields listed as required. Stores all fields in requiredFiles array. Parameters: Name Type Description schema Object schema to traverse in search for all required fields Source: controllers/validation.js, line 156 getAutoPopulatedFields(basicFields) Finds basic API fields are to be auto-populated Parameters: Name Type Description basicFields Array Fields(Objects) which are stored in SUDS Source: controllers/basic.js, line 31 Returns: Fields(Objects) which are to be auto-populated Type Array getBasicFields(fields, body, autoPopValues) Parameters: Name Type Description fields Array All fields in object form which will be sent to basicAPI body Object user input autoPopValues Object All values which have been auto-populated Source: controllers/basic.js, line 69 Returns: Array of post objects Type Array getBody(req) If body passed in as string, converts it to a JSON object Parameters: Name Type Description req Object request object Source: controllers/index.js, line 66 Returns: request body as a JSON Object Type Object getDataToStoreInDB(schema, body) Formats data from user input, that needs to be submitted to DB, so that DB can receive it. Parameters: Name Type Description schema Object Schema of application being submitted body Object User input Source: controllers/db.js, line 171 Returns: Containing key:value pairs for all fields expected to be stored in DB Type Object getFieldsToStore(schema, fieldsToStore, path, saveLocation) Gets list of fields that are to be stored in DB Parameters: Name Type Description schema Object Schema to look through to find any fields to store in DB fieldsToStore Array Array(String) containing names of field to store in DB path String path to each field from root of schema saveLocation String location which field should be saved. Valid options are middleLayer or basic. Source: controllers/db.js, line 125 getValidationSchema(pathData) Get the schema to be used for validating user input Parameters: Name Type Description pathData Object All data from swagger for the path that has been run Source: controllers/validation.js, line 289 Returns: schemas - fullSchema is the full validation schemas for all permit types. schemaToUse is the validation schema for this route Type Object handleAnyOfError(errorTracking, result, counter) Creates error object for errors resulting from an anyOf section of the validation schema Parameters: Name Type Description errorTracking object Error object containing all error to report and the error message to deliver. Properties Name Type Description errorArray array Array contain all errors to report to user. result array Array of errors found during validation. counter integer Position in result that the current error being handled is. Source: controllers/validation.js, line 273 makeAnyOfMessage(anyOfFields) Creates error message for anyOf errors Parameters: Name Type Description anyOfFields array list of fields, at least one being required. Source: controllers/validation.js, line 399 Returns: Type string makeErrorObj(field, errorType, expectedFieldType, enumMessage, dependency, anyOfFields) Creates error object which can be read by error message building function Parameters: Name Type Description field string Field where error occured at errorType string Type of error returned expectedFieldType string Type that the field is expected to be enumMessage string Enum message returned by validation dependency string Fields that are a dependeny of field anyOfFields array Array of strings of all field included in anyOf Source: controllers/validation.js, line 121 Returns: Error object postToBasic(req, res, sch, body) Sends requests needed to create an application via the Basic API Parameters: Name Type Description req Object Request Object res Object Response Object sch Object Schema object body Object User input Source: controllers/basic.js, line 207 prepareBasicPost(sch, body) Takes fields to be stored, creates post objects and populated with user input Parameters: Name Type Description sch Object validation schema for this request body Object user input Source: controllers/basic.js, line 133 Returns: All post objects Type Array processErrors(errors, processedErrors) Processes ValidationError into ErrorObj, extracting the info needed to create an error message Parameters: Name Type Description errors Array Array of ValidationErrors from validation processedErrors Array Array to store processed ErrorObjs in Source: controllers/validation.js, line 323 removeInstance(prop) Removes 'instance' from prop field of validation errors. Used to make fields human readable Parameters: Name Type Description prop string Prop field from validation error Source: controllers/validation.js, line 71 Returns: Type string validateBody(body, pathData) Validates the fields in user input Parameters: Name Type Description body Object Input from user to be validated pathData Object All data from swagger for the path that has been run Source: controllers/validation.js, line 304 Returns: Array of ValidationErrors from validation Type Array Ã— Search results Close Documentation generated by JSDoc 3.4.3 on April 11, 2017 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" US Forest Service ePermit Middlelayer API Global buildAutoPopulatedFieldscombinePropArgumentfindFieldgetAllFileNamesgetAllRequiredgetAutoPopulatedFieldsgetBasicFieldsgetBodygetDataToStoreInDBgetFieldsToStoregetValidationSchemahandleAnyOfErrormakeAnyOfMessagemakeErrorObjpostToBasicprepareBasicPostprocessErrorsremoveInstancevalidateBody US Forest Service ePermit Middlelayer APIA repository for the development of an API to support the public facing ePermit system to connect to the related Forest Service database, the Special Use Data System (SUDS) located in the National Resource Management System. This repository is being development under a task order of the Agile Blanket Purchase Agreement. Setup Clone or download this repository. Run npm install to install application and all dependencies. Run npm start to start Node.js server. How to Test Scripts Use npm test to run Mocha unit tests. Use npm run coverage for Istanbul code coverage. Results in /coverage folder. Use npm run lint for ESLint static code analysis. Results in /lint folder. Use npm run fix for ESLint code fix. Use npm run dba to run Sequelize migration and seeder. Use npm run doc to run JSDoc code documentation. Results in /code-docs folder. Data Files: Test files are stored in test/data directory Accounts: Test accounts are stored in environment variables ADMINROLE_USER, ADMINROLE_PWD, ADMINROLE_HASH USERROLE_USER, USERROLE_PWD, USERROLE_HASH Configuration Environment variables: PORT | Default: 8000 DATABASE_URL | Format: postgres://user:password@host:port/database AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_REGION AWS_BUCKET_NAME Dotenv: Dotenv is used which can load environment variables from a .env file into process.env Example: PORT=8080 DependenciesRefer to application package and dependency trackers for additional dependency information: Infrastructure: Runtime: Node.js &gt;= 6.9.x Engine: NPM &gt;= 3.10.x Database: PostgreSQL &gt;= 9.6.x Storage: AWS S3 Application package: package.json npm-shrinkwrap.json Dependency trackers: Gemnasium VersionEye Bithound Point of Contact and NotificationsYou can report issues and submit questions by opening a new Issue in GitHub. You can Watch this repo to receive notifications from GitHub when a new issue is posted, when an existing issueâ€™s status is updated, and when a pull request is created. ContributingSee CONTRIBUTING for additional information. Public DomainThis project is in the worldwide public domain. As stated in CONTRIBUTING: This project is in the public domain within the United States, and copyright and related rights in the work worldwide are waived through the CC0 1.0 Universal public domain dedication. All contributions to this project will be released under the CC0 dedication. By submitting a pull request, you are agreeing to comply with this waiver of copyright interest. Ã— Search results Close Documentation generated by JSDoc 3.4.3 on April 11, 2017 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
